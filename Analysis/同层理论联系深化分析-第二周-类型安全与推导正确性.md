# 同层理论联系深化分析 - 第二周：类型安全与推导正确性

## 一、目标与范围

- 给出 STLC 与 System F 的类型安全（preservation/progress）形式化陈述与证明框架。
- 构建小步语义、替换引理、规范化等关键引理的组织结构。
- 结合工程化推导（算法化检查/推导）给出正确性（soundness/completeness）边界。

---

## 二、操作语义与上下文

### 2.1 小步语义（片段）

- β-规约： (λx:T.e) v ↦ e[x := v]
- 上下文规约：e ↦ e' ⇒ E[e] ↦ E[e']

### 2.2 环境与替换

- 变量替换：e[x := v]
- 类型替换（System F）：t[α := S]

---

## 三、关键引理组织

### 3.1 替换引理（值替换）

Lemma（STLC）：若 Γ, x:T ⊢ e : U 且 Γ ⊢ v : T，则 Γ ⊢ e[x := v] : U。

Sketch：对 e 的推导作归纳；应用处利用箭头消解。

### 3.2 类型替换引理（System F）

Lemma（System F）：若 Γ ⊢ t : T 且 α 不自由于 Γ，则 Γ ⊢ t[α := S] : T[α := S]。

Sketch：对推导归纳；在 ∀-实例化规则处应用归纳假设。

### 3.3 进—保核心定理

- Preservation：若 Γ ⊢ t : T 且 t ↦ t'，则 Γ ⊢ t' : T。
- Progress：若 ⊢ t : T，则 t 为值或存在 t' 使得 t ↦ t'。

Proof idea：对最后一步推导与规约做双归纳；关键在应用、类型应用与匹配形式。

---

## 四、规范化与强规范化讨论

- STLC：强规范化（无发散归约序列）。
- System F：可借助 Tait/Girard 可还原性（reducibility candidates）技术证明强规范化，但工程层面通常以擦除与运行时等价为主。

---

## 五、算法化推导与正确性

### 5.1 STLC 的算法化推导

- 约束生成：遍历语法生成等式约束
- 合一算法：求解类型变量替换 σ
- 正确性：Soundness（算法推导的类型可被演绎系统导出）、Completeness（若可导出则存在解满足约束）

```rust
// 约束生成与合一（简化伪代码）
fn generate_constraints(e: Expr) -> Vec<Constraint> { /* ... */ }
fn unify(cs: Vec<Constraint>) -> Result<Subst, UnifyError> { /* ... */ }
fn infer(e: Expr) -> Result<Type, TypeError> {
    let cs = generate_constraints(e);
    let σ  = unify(cs)?;
    Ok(apply(σ, fresh_type_var_of(e)))
}
```

注意：完整 HM 推断需要 let-多态；此处 STLC 场景下常以注解或受限推断替代。

### 5.2 System F 的检查与局部推断

- 类型检查：依赖显式注解，检查 ∀-抽象与实例化。
- 局部推断：在应用位置为类型变量生成占位与约束，SMT/搜索求解。
- 正确性：Soundness 明确；Completeness 通常受限于启发式与注解策略。

---

## 六、错误定位与反例最小化

- 最短反例：在失败分支保留最短子项，输出最小冲突切片。
- 约束回溯：定位导致合一失败的约束对（s ≠ t）。
- 语义差异：基线与变更版本对同程序的类型差异报告。

```rust
// 失败切片（伪代码）
fn minimize_counterexample(e: Expr, err: TypeError) -> ExprSlice {
    // 递归缩减 e，保持同样的错误以定位根因
    unimplemented!()
}
```

---

## 七、与后续系统层的衔接

- 与并发/分布式：类型视作不变式（protocol/state refinement）的静态证据。
- 与验证工具：生成可消费的证据（proof obligations），进入模型检查/定理证明流程。

---

## 八、结论

- 给出 STLC/System F 的安全性与推导正确性组织框架与工程接口。
- 为“应用协同”与后续系统层的互操作打下可验证基础。 